// Основы работы с событиями
// Раздел на сайте: http://learn.javascript.ru/events-and-interfaces

// 1. Введение в браузерные события:
// http://learn.javascript.ru/introduction-browser-events
// * Событие – это сигнал от браузера о том, что что-то произошло. События:
// События мыши:
// -- click – происходит, когда кликнули на элемент левой кнопкой мыши
// -- contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши
// -- mouseover – возникает, когда на элемент наводится мышь
// -- mousedown и mouseup – когда кнопку мыши нажали или отжали
// -- mousemove – при движении мыши
// События на элементах управления:
// -- submit – посетитель отправил форму <form>
// -- focus – посетитель фокусируется на элементе, например нажимает на <input>
// Клавиатурные события:
// -- keydown – когда посетитель нажимает клавишу
// -- keyup – когда посетитель отпускает клавишу
// События документа:
// -- DOMContentLoaded – когда HTML загружен и обработан, DOM документа
// полностью построен и доступен.
// События CSS:
// -- transitionend – когда CSS-анимация завершена
// * Событию можно назначить обработчик, то есть функцию, которая сработает,
// как только событие произошло.
// * Назначение обработчиков событий - способы:
// 1) Использование HTML атрибута on<событие>, напр., onclick и т. д. При таком
// заднии браузер автоматически создаёт функцию из содержимого атрибута.
// 2) Исп. св-ва on<событие> DOM-элемента (установка атрибута записывает в св-во
// как раз эту созданную функцию):
elem.onclick; elem.onmouseover; // и т. д.
// - Внутри обработчика события this ссылается на текущий элемент.
// - (!) Не используйте setAttribute при назначении событий.
// 3) Способ, позволяющий обойти ограничение невозможности назначения нескольких
// обработчиков на одно событие (event-name БЕЗ on):
elem.addEventListener("event-name", handler1, phase);
elem.addEventListener("event-name", handler2, phase);
elem.removeEventListener("event-name", handler1, phase);
elem.removeEventListener("event-name", handler2, phase);
// - (!) Удаление требует именно ту же функцию.
// - Можно одновременно назначать обработчики и через DOM-свойство и через
// addEventListener, но так делать не рекомендуется.
// - "+" 3-го способа в том, что не все события можно назвачить 2-м способом.
// 3.1) В IE8- вместо add/removeEventListener используются свои методы:
// element.attach/detachEvent("on" + event, handler) (подробнее в статье).

// 2. Порядок обработки событий:
// http://learn.javascript.ru/events-and-timing-depth
// * События могут возникать не только по очереди, но и «пачкой» по много сразу. Возможно, что во время обработки одного события возникают другие.
// * В каждом окне выполняется только один главный поток, выполняющий js.
// Он выполняет команды посл-но и блокируется при выводе модальных окон.
// * Web Workers позволяют запускать доп. js-потоки: https://vk.cc/6R4BCy
// * Обработка событий:
// - Когда происходит событие, оно попадает в очередь (вып. беск. цикл)
// - Иногда события добавляются в очередь "сразу пачкой".
// - Нек. события работают синхронно (пример: onfocus НЕ в IE
// - Неасинхронность событий можно обойти, обернув вызов события в
// конструкцию вида setTimeout(() => elem.focus(), 0).

// 3. Объект события: http://learn.javascript.ru/obtaining-event-object
// * Детали события браузер записывает в специальный объект события. Он
// передаётся первым аргументом в обработчик. Нек. св-ва объекта event:
event.type; // тип события (напр., click)
event.currentTarget; // эл-т, на котором сработал обработчик(=this почти всегда)
event.clientX; event.clientY; // коорд. курсора (отн. окна) в момент клика
// * Объект события также доступен в HTML (в аргументе события).
// * IE8- не передаёт параметр, а создаёт глоб. объект window.event

