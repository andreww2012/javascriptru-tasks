// Это не решение задачи, а примеры использования новых возможностей плюс их краткое описание.
// Записываю для себя. Полная статья: http://learn.javascript.ru/es-class

// 1. Новый синтаксис для классов (по факту синтаксический сахар)
// Функция constructor запускается при создании new User, остальные методы записываются в
// User.prototype.
// При объявлении через class есть ряд отличий от классического объявления:
// - класс нельзя вызывать без new, будет ошибка;
// - объявление класса видно только в текущем блоке и только в коде, который находится ниже
// объявления.
// Методы, объявленные внутри class, также имеют ряд особенностей:
// - метод sayHi является именно методом, то есть имеет доступ к super.
// - все методы класса работают в строгом режиме use strict, даже если он не указан.
// - все методы класса не перечислимы. То есть в цикле for..in по объекту их не будет.
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}
let user = new User("Вася");
user.sayHi(); // Вася

// 2. Class Expression
// Можно создавать классы прямо в выражении:
let User2 = class { sayHi() { alert('Привет!'); } };
// Можно и в таком объявлении задать имя классу:
let SiteGuest = class User { sayHi() { alert('Привет!'); } }; // User недоступна извне

// 3. Геттеры, сеттеры, вычисляемые свойства
// В классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через get/set,
// а также использовать […] для свойств с вычисляемыми именами:
class User3 {
  constructor(firstName, lastName) {
    this.firstName = firstName;
    this.lastName = lastName;
  }
  get fullName() { return `${this.firstName} ${this.lastName}`; }
  set fullName(newValue) { [this.firstName, this.lastName] = newValue.split(' '); }
  ["test".toUpperCase()]() { alert("PASSED!"); }
};

// 4. Статические свойства
// Для их объявления используется ключевое слово static:
class User4 {
  static test() {
    // ...
  }
};
// Также статическими удобно делать константы:
class Menu {
  static get elemClass() {
    return "menu"
  }
}

// 5. Наследование
// Производится с помощью ключевого слова extends. Особенности:
// - методы родителя можно переопределить в наследнике. Для обращения к родительскому методу
// используют super.walk();
// - конструктор родителя наследуется автоматически: если в потомке не указан свой constructor,
// то используется родительский;
// - если у потомка свой constructor, то чтобы в нём вызвать конструктор родителя – используется
// синтаксис super(), НО:
// * вызвать конструктор родителя можно только изнутри конструктора потомка;
// * в конструкторе потомка мы __обязаны__ вызвать super() до обращения к this.
class Animal {
  walk() { alert("Animal's walk"); }
}
class Rabbit extends Animal {
  walk() { super.walk(); alert("Rabbit's walk") };
}
