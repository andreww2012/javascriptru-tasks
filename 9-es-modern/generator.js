// Это не решение задачи, а примеры использования новых возможностей плюс их краткое описание.
// Записываю для себя. Полная статья: http://learn.javascript.ru/generator

// 1. Понятие генератора
// Генераторы – особый вид функций. Такие функции могут приостанавливать своё выполнение,
// возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.
// Для объявления генератора исп. конструкция function* (функция-генератор или generator function).
// Можно ставить звёздочку как сразу после function, так и позже, перед названием.
function* genSequence() {
  yield 1; yield 2; return 3;
}

// 2. Запуск и выполнение генератора
// При запуске genSequence() функция-генератор возвр. спец. объект, который называют генератором.
let generator = genSequence(); // generator function не выполняется, но создаёт generator
// При вызове метода next() генератора он возобновляет выполнение кода до ближайшего yield. По
// его достижении выполнение приостанавливается, а значение возвращается во внешний код:
alert(JSON.stringify(generator.next())); // {value: 1, done: false}
// Повторный вызов generator.next() возобновит выполнение и вернёт результат следующего yield:
alert(JSON.stringify(generator.next())); // {value: 2, done: false}
// И, наконец, последний вызов завершит выполнение функции и вернёт результат return:
alert(JSON.stringify(generator.next())); // {value: 3, done: true}
// Новые вызовы generator.next() будут возвращать один и тот же объект: {done: true}.
// «Открутить назад» завершившийся генератор нельзя.

// 3. Связь генераторов с итераторами
// Генератор является итерируемым объектом, т. е. его можно перебирать и через for..of:
let generator2 = genSequence();
for (let value of generator) { alert(value); } // 1, затем 2
// Зн-е 3 выведено не будет, т. к. стандартный перебор итератора игнор. value на последнем значении,
// при done: true. Чтобы при переборе возвращались все значения, надо возвращать их через yield.

// 4. Композиция генераторов
// Один генератор может включать в себя другие. Это называется композицией. Пример:
function* generateSequence(start, end) { for (let i = start; i <= end; i++) yield i; }
function* generateAlphaNum() {
  yield* generateSequence(48, 57); // 0..9
  yield* generateSequence(65, 90); // A..Z
  yield* generateSequence(97, 122); // a..z
}
let str = ''; for (let code of generateAlphaNum()) { str += String.fromCharCode(code); }
alert(str); // 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
// yield* применима только к функции-генератору и делегирует ей выполнение
// Получается – как будто мы вставили код внутреннего генератора во внешний напрямую.

// 5. Дополнительные возможности yield
// yield не только возвращает результат наружу, но и может передавать значение извне в генератор.
// Так, вызов let result = yield value делает следующее:
// * Возвращает value во внешний код, приостанавливая выполнение генератора.
// * Внешний код может обработать значение, и затем вызвать next с аргументом: generator.next(arg).
// * Генератор продолжит вып-е, аргумент next будет возвращён как рез-т yield (и записан в result).
function* gen() {
  let result = yield "2 + 2?"; // Передать вопрос во внешний код и подождать ответа
  alert(result);
}
let generator = gen();
let question = generator.next().value; // Начинает выполнение и возвращает результат первого yield
setTimeout(() => generator.next(4), 2000); // Вып-е генератора возобновл., 4 присв. в result
// Вывод: каждый next(value), кроме первого, передаёт в генератор значение, которое становится
// результатом текущего yield, возобновляет выполнение и получает выражение из следующего yield.

// 6. Передача ошибок от внешнего кода в генератор
// Производится через generator.throw(err), таким образом на строке с yield возникает исключение.
function* gen_() {
  try { let result = yield "Сколько будет 2 + 2?"; } catch(e) { alert(e); }
}
let generator_ = gen_();
let question = generator.next().value;
generator.throw(new Error("ответ не найден в моей базе данных"));
// Если ошибку не перехватить, она «выпадет» из генератора, и можно её в строке с throw.
// Если ошибка и там не перехвачена, то дальше – либо try..catch снаружи, либо она «повалит» скрипт.

// 7. Плоский асинхронный код
// Это одна из основных областей применения генераторов. Общий принцип такой:
// * Генератор yield'ит не просто значения, а промисы.
// * Есть спец. ф-я execute(generator), которая запускает ген-р, послед-ми вызовами next получает
// из него промисы и, когда очередной промис выполнится, возвр. его р-т в генератор следующим next.
// * Посл. зн-е генератора (done:true) execute уже обрабатывает как окончательный результат.
// Пример такой функции в статье про генераторы на сайте.

// 8. [Не относится напрямую к генераторам]: Библиотека co (https://github.com/tj/co)
// 8.1. Основные возможности библиотеки
// Библиотека co, как и execute в примере на сайте, получает генератор и выполняет его. Пример:
co(function*() {
  let result = yield new Promise(
    resolve => setTimeout(resolve, 1000, 1)
  );
  alert(result); // 1
});
// Вызов co() возвращает промис с результатом генератора. Если в примере выше function*() что-то
// возвратит, то это можно будет получить через .then в результате co.
co(function*() {
  let result = yield new Promise(
    resolve => setTimeout(resolve, 1000, 1)
  );
  return result;
}).then(alert); // 1
// Обрабатывать результат co всегда нужно, так, например, данный код ничего не выведет:
co(function*() {
  throw new Error("Sorry that happened");
});
// Правильно:
co(function*() {
  throw new Error("Sorry that happened");
}).catch(alert);

// 8.2. Дополнительные возможности
// Библиотека co умеет выполнять не только промисы, но и:
// * Объект-генератор.
// * Функция-генератор function*() – co её выполнит, затем выполнит полученный генератор.
// * Ф-я с одним аргументом вида function(callback) – co её запустит со своей функцией-callback и
// будет ожидать, что при ошибке она вызовет callback(err), а при успешном выполнении – callback
// (null, result). После чего результат будет передан в генератор.
// * Массив или объект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и
// результат, в той же структуре, будет выдан наружу.
// Примеры см. в статье про генераторы на сайте.

// 8.3. Устаревшая конструкция yield function(callback)
// Конструкция yield function(callback), которую называют thunk, устарела. Ф-я обязана выполниться
// и вызвать (асинхронно) либо callback(err) с ошибкой, либо callback(null, result) с результатом.
// Это устаревшая конструкция, поскольку вместо этого можно использовать промисы.

// 8.4. Два способа yield'а генераторов
// Библиотека co технически позволяет писать код так:
let user = yield fetchUser(url); // вместо yield*, где fetchUser - функция-генератор.
// Однако, написание yield вместо yield* не рекомендуется по ряду причин:
// * Делегирование генераторов yield* – это встроенный механизм JavaScript, т. е. это быстрее
// * Делегирование генераторов сохраняет стек.
