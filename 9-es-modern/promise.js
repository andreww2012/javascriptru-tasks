// Это не решение задачи, а примеры использования новых возможностей плюс их краткое описание.
// Записываю для себя. Полная статья: http://learn.javascript.ru/promise

// 1. Promise
// Промисы предоставляют удобный способ организации асинхронного кода. Promise – это специальный
// объект, который содержит своё состояние. Вначале pending, затем – одно из: fulfilled или
// rejected («выполнено с ошибкой»).
// На promise можно навешивать коллбэки двух типов: onFulfilled – срабатывают, когда promise в
// состоянии «выполнен успешно», onRejected – срабатывают, когда promise в состоянии «выполнен с
// ошибкой». Синтаксис создания:
var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически. В ней можно делать любые асинхронные операции, а
  // когда они завершатся — нужно вызвать одно из: resolve(результат) при успешном выполнении,
  // reject(ошибка) (или throw new Error("сообщение") - это то же самое, что reject(new Error
  // ("сообщение"))) при ошибке.
  // Функции resolve/reject принимают ровно один аргумент – результат/ошибку.
});

// 2. Методы для навешивания обработчиков на promise
// С помощью метода then() можно назначить как оба обработчика сразу, так и только один:
// onFulfilled сработает при успешном выполнении, onRejected - при ошибке
promise.then(onFulfilled, onRejected);
promise.then(onFulfilled); // Назначение одного обработчика
// то же самое, что promise.then(null, onRejected) - также один обработчик
promise.catch(onRejected);

// 3. Промисы после reject/resolve неизменны
// После вызова resolve/reject промис уже не может «передумать». Когда промис переходит в состояние
// «выполнен» – с результатом (resolve) или ошибкой (reject) – это навсегда. Пример:
let promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("result"), 1000); // через 1 секунду готов результат: result
  // через 2 секунды — reject, будет проигнорирован
  setTimeout(() => reject(new Error("ignored")), 2000);
});
promise.then(
  result => alert("Fulfilled: " + result), // сработает
  error => alert("Rejected: " + error) // не сработает
);

// 4. Промисификация
// Промисификация – это когда берут асинхронный функционал и делают для него обёртку,
// возвращающую промис:
function httpGet(url) {
  return new Promise(function(resolve, reject) {
    // асинхронный код
  });
}
httpGet("url here").then( // использование
    response => alert(`Fulfilled: ${response}`),
    error => alert(`Rejected: ${error}`)
);

// 5. Цепочки промисов (чейнинг)
// Существует возможность создавать асинхронные цепочки из промисов следующим образом:
// httpGet(...).then(...).then(...).then(...)
// - При чейнинге в каждый следующий then переходит результат от предыдущего.
// - для того, чтобы результат обработчика передать следующей функции, .then создаёт новый промис
// и возвращает его.
// - Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис,
// а его результат. При этом до выполнения промиса может пройти некоторое время, оставшаяся часть
// цепочки будет ждать.
// - Общее правило: если внутри then стартует новый асинхронный процесс, то для того, чтобы
// оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис.

// 6. Перехват ошибок
// При возникновении ошибки, она отправляется в ближайший обработчик onRejected. Такой обработчик
// нужно поставить через второй аргумент .then(..., onRejected) или, что то же самое, через
// .catch(onRejected).
// Чтобы поймать всевозможные ошибки при чейнинге, нужно добавить catch в конец цепочки.

// 7. Промисы в деталях
// - Согласно стандарту, у объекта new Promise(executor) при создании есть четыре внутренних
// свойства:
// PromiseState – состояние, вначале «pending»;
// PromiseResult – результат, при создании значения нет;
// PromiseFulfillReactions/PromiseRejectReactions – ф-ии-обработчики успешного выполнения/ошибки.
// - Когда executor вызывает reject/resolve, то PromiseState становится "resolved"/"rejected"
// соответственно а все функции-обработчики из соответствующего списка перемещаются в специальную
// системную очередь "PromiseJobs".
// Эта очередь автоматически выполняется, когда интерпретатору «нечего делать».
// - Исключение из этого правила – если resolve возвращает другой Promise. Тогда дальнейшее
// выполнение ожидает его результата (в очередь помещается специальная задача), и
// функции-обработчики выполняются уже с ним.
// - Метод .then делет следующее:
// Если PromiseState == "pending", то есть промис ещё не выполнен, то обработчики добавляются в
// соотв. списки. Иначе обработчики сразу помещаются в очередь на выполнение.
// - .then, если один из обработчиков не указан, добавляет его «от себя», следующим образом:
// для успешного выполнения - ф-ю Identity, которая выглядит как arg => arg, для ошибки –
// ф-ю Thrower: arg => throw arg

// 8. Promose.all(iterable)
// Получает массив (или другой итерируемый объект) промисов и возвращает промис, который
// ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом
// их результатов.
// Если какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка.
// При этом остальные промисы игнорируются.
Promise.all([
  httpGet('/article/promise/user.json'), // httpGet определена выше
  httpGet('/article/promise/guest.json')
]).then(results => {
  alert(results);
});

// 9. Promise.race(iterable)
// То же самое, что Promise.all(), но результатом будет только первый успешно выполнившийся промис
// из списка. Остальные игнорируются.

// 10. Promise.resolve(value), Promose.reject(value)
// Создают успешно/неуспешно выполнившийся промис соответственно с результатом value.
// Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат
// уже есть.
// Promose.resolve аналогичен конструкции:
new Promise((resolve) => resolve(value));
