// Это не решение задачи, а примеры использования новых возможностей плюс их
// краткое описание. Записываю для себя.
// Полная статья: http://learn.javascript.ru/symbol

// 1. Новый примитивный тип данных Symbol служит для создания уникальных
// идентификаторов. Создание символа и его typeof:
let sym = Symbol();
alert(typeof sym); // symbol

// 2. У функции Symbol есть необязательный аргумент «имя символа». Его можно
// использовать для описания символа в целях отладки. Каждый символ сам по себе
// уникален.
let sym2 = Symbol("name");
alert(sym2.toString()); // Symbol(name)
alert(Symbol("name") == Symbol("name")); // false

// 3. Глобальные символы можно получать из глобального реестра по имени (и
// добавлять туда) с помощью Symbol.for.
// Symbol.keyFor(sym), наоборот, позволяет получить по глобальному символу его
// имя. ВАЖНО: Symbol.keyFor возвращает undefined, если символ не глобальный.
let name = Symbol.for("symbolName"); // создание символа в реестре
alert(Symbol.for("symbolName") == name); // true
alert(Symbol.keyFor(name)); // symbolName

// 4. Использование символов
// Символы можно использовать в качестве имён для свойств объекта.
// Свойство-символ не участвует в итерации:
let user = {name: "Вася", age: 30, [Symbol.for("isAdmin")]: true};
alert(Object.keys(user)); // name, age (нет символа)
// доступ к свойству через глобальный символ — работает
alert(user[Symbol.for("isAdmin")]);

// 5. Некоторые системные символы
// Symbol.toPrimitive – идентификатор для свойства, задающего функцию
// преобразования объекта в примитив.
// Symbol.iterator – идентификатор для свойства, задающего функцию итерации по
// объекту.

// 6. Получение всех символов объекта: Object.getOwnPropertySymbols.
// getOwnPropertyNames символы НЕ возвращает.
