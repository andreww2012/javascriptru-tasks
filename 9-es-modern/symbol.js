// Это не решение задачи, а примеры использования новых возможностей плюс их краткое описание.

// Новый примитивный тип данных Symbol служит для создания уникальных идентификаторов.
// Создание символа и его typeof:
let sym = Symbol();
alert(typeof sym); // symbol

// У функции Symbol есть необязательный аргумент «имя символа». Его можно использовать для описания символа
// в целях отладки. Каждый символ сам по себе уникален.
let sym2 = Symbol("name");
alert(sym2.toString()); // Symbol(name)
alert(Symbol("name") == Symbol("name")); // false

// Глобальные символы можно получать из глобального реестра по имени (и добавлять туда) с помощью Symbol.for.
// Symbol.keyFor(sym), наоборот, позволяет получить по глобальному символу его имя.
// ВАЖНО: Symbol.keyFor возвращает undefined, если символ не глобальный.
let name = Symbol.for("symbolName"); // создание символа в реестре
alert(Symbol.for("symbolName") == name); // true
alert(Symbol.keyFor(name)); // symbolName

// Использование символов
// Символы можно использовать в качестве имён для свойств объекта. Свойство-символ не участвует в итерации:
let user = {name: "Вася", age: 30, [Symbol.for("isAdmin")]: true};
alert(Object.keys(user)); // name, age (нет символа)
alert(user[Symbol.for("isAdmin")]); // доступ к свойству через глобальный символ — работает

// Некоторые системные символы
// Symbol.toPrimitive – идентификатор для свойства, задающего функцию преобразования объекта в примитив.
// Symbol.iterator – идентификатор для свойства, задающего функцию итерации по объекту.

// Получение всех символов объекта: Object.getOwnPropertySymbols. getOwnPropertyNames символы НЕ возвращает.
