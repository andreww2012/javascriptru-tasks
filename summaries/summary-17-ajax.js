// AJAX и COMET
// Раздел на сайте: https://learn.javascript.ru/ajax

// 1. Введение в AJAX и COMET: https://learn.javascript.ru/ajax-intro
// * AJAX («Asynchronous Javascript And Xml») – технология обращения к серверу
// без перезагрузки страницы.
// * COMET – общий термин, описывающий различные техники получения данных по
// инициативе сервера. Примеры COMET-приложений: чат, аукцион, интерфейс
// (совместного) редактирования.
// * Библиотеки/фреймворки, добавляющие удобства: Socket.io, CometD.

// 2. Node.JS для решения задач: https://learn.javascript.ru/ajax-nodejs
// В статье приводится краткая инструкция по установке/настройке NodeJS/npm
// и приводится пример создания простого сервера (см. example-server.js)

// 3. Основы XMLHttpRequest: https://learn.javascript.ru/ajax-xmlhttprequest
// * Как правило, объект XMLHttpRequest используют для загрузки данных.
let xhr = new XMLHttpRequest();
// Параметры open: тип, путь, асинхронно?, логин/пароль для HTTP-авторизации
xhr.open("POST", "phones.json", false); // настраивает запрос, но не откр. соед.
// Установка заголовков (не все заголовки можно уст. в целях безопасности).
// Также заг-к нельзя снять, повторные вызовы лишь добавляют информацию к нему.
xhr.setRequestHeader("Content-Type", "application/json");
xhr.timeout = 3000; // макс. продолжительность асинхр. запроса
xhr.send("тело-запроса"); // тело указ., если есть(напр, его нет в GET-запросах)
xhr.abort(); // прерывает выполнение запроса
xhr.onreadystatechange = () => { xhr.readyState; }; // см. описание ниже
xhr.ontimeout = () => {  }; // возникает при превышении timeout
xhr.onloadstart = () => {  }; // запрос начат
xhr.onprogress = () => {  }; // получен очередной пакет данных
xhr.onabort = () => {  }; // запрос был отменён
xhr.onerror = () => {  }; // произошла ошибка
xhr.onload = () => {  }; // запрос был завершён без ошибок
xhr.onloadend = () => {  }; // запрос был завершён (неважно как)
xhr.status; xhr.statusText; // код ответа сервера + его описание
xhr.responseText; // текст ответа
xhr.responseXML; // если ответ в XML-формате, то это XML-документ (исп. редко)
xhr.getResponseHeader("Content-Type"); // не возвр. Set-Cookie, Set-Cookie2
xhr.getAllResponseHeaders(); // возвр. всё кроме Set-Cookie/..2 в виде строки(!)
// * Синхр. запросы исп. очень редко (блокируется взаимодействие со страницей).
// Если синхр. вызов занял много времени, то браузер предложит закрыть страницу.
// * Соб. readystatechange происх. неск. раз в процессе отсылки и получ. ответа.
// Св-во readyState содержит текущее состояние запроса:
// const unsigned short UNSENT = 0;  начальное состояние
// const unsigned short OPENED = 1;  вызван open
// const ... HEADERS_RECEIVED = 2;   получены заголовки
// const unsigned short LOADING = 3; загруж.тело(получен очередной пакет данных)
// const unsigned short = 4;         запрос завершён
// Запрос проходит их в порядке 0 → 1 → 2 → 3 → … → 3 → 4.
// См. в example-xmlhttprequest.js пример типичного XMLHttpRequest запроса.

// 4. XMLHttpRequest POST, формы и кодировка:
// http://learn.javascript.ru/xhr-forms
// 1) Отправка GET-запросов
// * Во время отправки формы <form> браузер собирает значения её полей, делает
// из них строку и составляет тело GET/POST-запроса для посылки на сервер.
// (!) При отправке данных через XMLHttpRequest это нужно делать самим в JS-коде
// * urlencoded - основной способ кодировки: все символы, кроме англ. букв, цифр
// и -_.!~*'() заменяются на их цифровой код в UTF-8 со знаком %. Спец. ф-я:
encodeURIComponent("Виктор"); // %D0%92%D0%B8%D0%BA%D1%82%D0%BE%D1%80
// * (!) При использовании XMLHttpRequest браузер автоматически добавит к
// запросу важнейшие HTTP-заголовки, такие как Content-Length и Connection.
// * Также можно сообщить серверу, что запрос отправляется через AJAX:
xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
// 2) Отправка POST-запросов
// * В формах для POST-запр. доступны 3 осн. кодировки, задаваемые через атрибут
// enctype: application/x-www-form-urlencoded, multipart/form-data, text-plain
// * В XHR мы не обязаны исп. ни один их этих способов, но проще всё-таки исп.:
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
// * Кодировка multipart/form-data обычно исп. для пересылки файлов. В этой
// кодир. поля пересылаются через спец. строку-разделитель (boundary). Так,
// сервер видит заголовок Content-Type: multipart/form-data, читает из него
// boundary - случайно сгенерированную строку, и раскодирует поля формы.
// * Сделать запрос в этой кодировке можно и в XHR. Надо указать в заголовке
// Content-Type кодировку и границу и далее сформировать тело запроса,
// удовлетворяющее требованиям кодировки. Пример см. в статье.
// * Можно созд. запрос, который сервер воспримет как загрузку файла. См. статью
// 3) FormData - объект, который кодирует формы для отправки на сервер. Пример:
let formData = new FormData(document.forms.person); // можно вызвать без арг-ов
formData.append("patronym", "Робертович");
let xhr = new XMLHttpRequest();
xhr.open("POST", "/url");
xhr.send(formData); // (!) Кодировка будет multipart/form-data
// 4) XHR не огранич. кодировку и формат пересылаемых данных, часто исп. JSON:
xhr.setRequestHeader("Content-type", "application/json; charset=utf-8");

// 5. XMLHttpRequest: кросс-доменные запросы (не подд. IE9-):
// http://learn.javascript.ru/xhr-crossdomain
// * Для поддержки кросс-доменных запросов в IE9- нужно исп. XDomainRequest:
let XHR = ("onload" in new XMLHttpRequest()) ? XMLHttpRequest : XDomainRequest;
let xhr = new XHR(); // подробнее об особенностях XDomainRequest в статье.
// * (!) Кросс-доменный запрос обязательно должен быть асинхронным:
xhr.open("GET", "http://anywhere.com/request", true);
// * На КД запросы специф-я CORS налагает огранич. Она делит запросы на 2 вида:
// - Простые: используют простые методы (GET, POST, HEAD), простые заголовки
// (Accept, Accept-Language, Content-Language, Content-Type с 3 зн-ями выше).
// - Непростые: все остальные. Для их выполнения нужно согласие сервера.
// * В КД запросы браузер доб. заголовок Origin - домен, с кот. осуществ. запр.
// Если получен загол. Access-Control-Allow-Origin=домен запроса или * => сервер
// разрешил КД запрос с данного домена: https://vk.cc/6TwRak
// Access-Control-Expose-Headers=<список загол.> => доступ js к указ. заголовкам
// (по умолч. скрипт может прочитать из ответа только «простые» заголовки:
// Cache-Control, Content-Language, Content-Type, Expires, Last-Modified,Pragma)
// * Указать браузеру передать вместе с запросом куки и HTTP-авторизацию:
xhr.withCredentials = true; // Для такого запроса сервер должен вернуть
// Access-Control-Allow-Origin: <домен>, Access-Control-Allow-Credentials: true
// * Если запрос - непростой, браузеры используют предзапрос (preflight):
// - Такой запрос исп. метод OPTIONS (илл.: https://vk.cc/6Tx3yP)
// - В Access-Control-Request-Method он указывает название желаемого метода,
// в Access-Control-Request-Headers - список добавленных особых заголовков.
// - При разрешении сервера он возвр. ответ без тела со статусом 200 и Access
// -Control-Allow-Method: метод, Access-Control-Allow-Headers: разреш.заголовки,
// может указать Access-Control-Max-Age: sec (кол-во сек. на разрешение)
// * Также, названия нестандартных заголовков ответа сервер должен указать в
// Access-Control-Expose-Headers, если хочет, чтобы клиент мог их прочитать.

// 6. XMLHttpRequest: индикация прогресса:
// http://learn.javascript.ru/xhr-onprogress
// * Запрос XMLHttpRequest состоит из двух фаз:
// - Стадия закачки (upload) - загрузка данных на сервер, событие xhr.upload
// - Стадия скачивания (download) - скачивание ответа с сервера, xhr.onprogress.
// 1) Стадия закачки: объект xhr.upload генерирует события в процессе закачки:
// loadstart, progress, abort, error, load, timeout, loadend.
// 2) Стадия скачивания:на этой стадии используются обработчики событий на объ.
// xhr (пример: xhr.onprogress содержит инф. о кол-ве принятых байт ответа)
// * Событие onprogress имеет с-ва:
// - loaded – кол-во уже пересланных данных в байтах (только тело, без загол-в)
// - lengthComputable - если true, то известно total
// - total – общее количество данных дл пересылки.
// Важные особенности события:
// - Событие происходит при каждом полученном/отправленном байте, но не чаще
// чем раз в 50 мс.
// - В процессе получения данных, ещё до их полной передачи, доступен
// xhr.responseText, но он не обязательно содержит корректную строку.
// - Сработавшее событие xhr.upload.onprogress не гарантирует, что данные дошли.
xhr.upload.onprogress = (e) => {alert("Загружено " + e.loaded + "/" + e.total);}
xhr.onprogress = (e) => {alert("Получ. с сервера" + e.loaded + "/" + e.total);}

// 7. XMLHttpRequest: возобновляемая закачка:
// http://learn.javascript.ru/xhr-resume
// *

// 8. COMET с XMLHttpRequest: длинные опросы:
// http://learn.javascript.ru/xhr-longpoll
// * COMET - непрерывное получения данных с сервера. Способы реализации:
// - Частые опросы: постоянная отсылка запросов на сервер (напр., каждые 10 с).
// Недостатки: задержки между событием и уведомлением, лишний трафик на сервер.
// - Длинные опросы, схема: https://vk.cc/6Ty0x2. Если соединение рвётся само,
// например, из-за ошибки в сети, то браузер тут же отсылает новый запрос.
// Пример реализации в статье.
// * Длинные опросы отлично работают в случаях, когда сообщения приходят редко.

// 9. WebSocket: http://learn.javascript.ru/websockets
// * WS - протокол для решения задач обмена данными между браузером и сервером.
// (!) Поддержке WS также требуется и на сервере. Создание WS и его коллбэки:
let socket = new WebSocket("ws://javascript.ru/ws"); // протоколы: ws, wss
socket.onopen; // Установление соединения
socket.onclose; // Соед. закрыто (e.code/reason-код/причина, e.wasClean-чистое?)
// Коды закрытия: 1000 - норм. закрытие;1001 - удал. сторона "исчезла"; 1002/3 -
// удал. сторона заверш. соед. в связи с ошибкой протокола/непринятием данных.
socket.onmessage; // Получение данных (доступны через e.data)
socket.onerror; // Ошибка (e.message)
socket.data(data); // Пересылает данные (любые)
// * WS работает над TCP, при соед. браузер "спрашивает" сервер, подд. ли он WS.
// Если ответ "да", что HTTP-запросы прекращаются, общение идёт на протоколе WS.
// P. S.: "подделать" запрос на устновление WS-соединения через XHR нельзя.
// * Указать, что по WS будут передаваться данные в протоколах SOAP или WAMP:
let socket = new WebSocket("ws://javascript.ru/ws", ["soap", "wamp"]);
// * Описание формата данных WS см. в статье; полный протокол WS: RFC 6455.
// * Подробнее про закрытие соединения: при закр. соед. сторона, желающая это
// сделать (обе стороны в WebSocket равноправны) отправляет закрывающий фрейм,
// в теле которого указывает причину закрытия. Есть такой фрейм=>чистое закрытие

// 10. Протокол JSONP: http://learn.javascript.ru/ajax-jsonp
// * С помощью тега <script src> можно загружать JSON-данные (альтернатива XHR).
// 1) Создание запроса (браузер запрашивает скрипт и выполняет его):
function addScript(src) {
  let elem = document.createElement("script");
  elem.src = src; document.head.appendChild(elem);
}
addScript("user?id=123");
// 2) Обработка ответа: JSONP подразумевает, что вместе с запросом клиент в
// заранее оговоренном параметре передаёт название ф-ии-коллбэка:
addScript("user?id=123&callback=onUserData");
// Сервер кодирует данные в JSON и оборачивает их в вызов функции из параметра:
onUserData({name: "Вася", age: 25}); // пример ответа сервера
// * Чтобы не засорять глобальное пространство имён ф-ями-коллбэками, используют
// один глобальный объект, пример:
addScript("user?id=123&callback=CallbackRegistry.func12345");
// * Обработка ошибок: создаём script -> на него ставим onload/onerror -> пусть
// при загрузке скрипт выполняет коллбэк, которая при запуске ставит флаг "ок"
// -> в обработчиках проверяем наличие флага.
// * Полный пример см. в статье.
// * COMET через SCRIPT реализуется при помощи длинных опросов (см. выше).

// 11. Server Side Events - события с сервера:
// http://learn.javascript.ru/server-sent-events
// * Объект EventSource обеспечивает соединение с сервером по протоколу HTTP.
// При односторонней передаче может быть удачной альтернативой вебсокетам.
// * При созд. объ. браузер автом. подкл. к адресу и получает с него события:
let eventSource = new EventSource("/events/subscribe");
eventSource.onmessage = (e) => { console.log(e.data); }; // новое сообщение
eventSource.onopen = (e) => {}; // соединение успешно установлено
eventSource.onerror = (e) => {}; // ошибка соединения
eventSource.close(); // закрыть соединение, открыть повторно больше нельзя
eventSource.readyState; // состояния: 0-пересоединение,1-соед.уст.,2-соед.закр.
// * Чтобы соединение успешно открылось, сервер должен ответить с заголовком
// Content-Type: text/event-stream, а затем оставить соединение висящим.
// Формат сообщений см. в статье.
// * (!) При создании объекта браузер автоматически подключается к серверу, а
// при обрыве – пытается его возобновить. Как серверу закрыть соединение:
// ответить со статусом не 200 или ответить c Content-Type: НЕ text/event-stream
// * Сервер может отправлять специальные заголовки id и event соответственно для
// идентификации события по ID и для кастомного имени события о сообщении
// * EventSource поддерживает кросс-доменные запросы, делать так:
let source = new EventSource("http://site.com", { withCredentials: true });
// При кросс-доменных запросах у событий event также появится дополнительное
// свойство origin, содержащее адрес источника, откуда пришли данные:
eventSource.addEventListener("message", (e) => {
  if (e.origin != "http://s.com") return;
});

// 12. IFRAME для AJAX и COMET: http://learn.javascript.ru/ajax-iframe
// Статья для старых IE, ненужная :)

// 13. Атака CSRF: http://learn.javascript.ru/csrf
// * Суть атаки состоит в отправке формы с домена злоумышленника на домен-жертву
// , где сейчас авторизован пользователь. Защита:
// 1) Сервер генерирует секретный ключ secret, только он знает о нём;
// 2) На основе ключа генерируется токен token (salt - случ. значение):
// token = salt + ":" + MD5(salt + ":" + secret)
// 3) token добавляется скрытым полем к форме на сайте:
/*
<form action="http://mail.com/send" method="POST">
<input type="hidden" name="csrf" value="1234:5ad02792a3285252e524ccadeeda3401">
</form> */
// 4) При отправке формы сервер проверит правильность поля csrf.
// * При работе с XHR: сервер устанавливает куку с именем CSRF-TOKEN, и пишет в
// неё токен; код, осуществляющий XHR, ставит заголовок X-CSRF-TOKEN: <кука>:
let request = new XMLHttpRequest();
let csrfCookie = document.cookie.match(/CSRF-TOKEN=([\w-]+)/);
if (csrfCookie) { request.setRequestHeader("X-CSRF-TOKEN", csrfCookie[1]); }

// 14. Метод fetch: замена XMLHttpRequest: http://learn.javascript.ru/fetch
// * Метод fetch по сравнению с XHR предоставляет улучшенный интерфейс для
// осуществления запросов к серверу, он построен на промисах. Синтаксис:
let promise = fetch(url, options); // Св-ва options:
// - method – метод запроса,
// - headers – заголовки запроса (объект),
// - body – тело запроса: FormData, Blob, строка и т.п.
// - mode – одно из: «same-origin», «no-cors», «cors», указывает, в каком
// режиме кросс-доменности предполагается делать запрос.
// - credentials – одно из: «omit», «same-origin», «include», указывает,
// пересылать ли куки и заголовки авторизации вместе с запросом.
// - cache – одно из «default», «no-store», «reload», «no-cache», «force-cache»,
// «only-if-cached», указывает, как кешировать запрос.
// - redirect – можно поставить «follow» для обычного поведения при коде 30x
// (следовать редиректу) или «error» для интерпретации редиректа как ошибки.
// * При вызове fetch возвращает промис, который, когда получен ответ,
// выполняет коллбэки с объектом Response или с ошибкой, если запрос не удался.
// Дальнейшая работа с промисом описана в статье и в описании к полифиллу fetch.

// 15. Таблица транспортов и их возможностей:
// http://learn.javascript.ru/ajax-summary
// Просто summary всего раздела "ajax".
